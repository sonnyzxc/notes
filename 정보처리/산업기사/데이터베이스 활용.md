### ==데이터베이스의 이해==
#### **자료 구조**
- 정선 - Vertex
- 간선 - Edge
- 인접행렬 - Adjacency Matrix

**트리**
- 정점 - Node
- 선분 - Branch
- 차수 - Degree 

**수식의 표기법**
- 전위 표기법 (Prefix) - Operator -> L -> R  (e.g. +AB)
- 중위 표기법 (Infix) - L -> Operator -> R (e.g. A+B)
- 후위 표기법 (Postfix) - L -> R -> Operator (e.g. AB+)
#### 정렬
**삽입 정렬 (Insertion Sort):** sorted | unsorted
e.g. `8 5 6 2 4`
- `8 [5] 6 2 4` -> `5 | 8 6 2 4`
- `5 | 8 [6] 2 4` -> `5 6 | 8 2 4`
- `5 6 | 8 [2] 4` -> `2 5 6 | 8 4`
- `2 5 6 | 8 [4]` -> `2 4 5 6 8`

**선택 정렬 (Selection Sort):** select `min(list)` from unsorted
e.g. `8 5 6 2 4`
- `8 5 6 [2] 4` -> `2 | 5 6 8 4`
- `2 | 5 6 8 [4]` -> `2 4 | 6 8 5`
- `2 4 | 6 8 [5]` -> `2 4 5 | 6 8`
- `2 4 5 | [6] 8` -> `2 4 5 6 | 8`
- `2 4 5 6 | [8]` -> `2 4 5 6 8`

**퀵 정렬 (Quick Sort):** 분할과 정복 (D&Q) 

**2-Way 합병 정렬 (Merge Sort):** 두 개씩 묶은 후 각각의 묶음 안에서 정렬; repeat
#### 해싱
**슬롯 (Slot):** 한 개의 레코드를 저장할 수 있는 공간으로 n개의 슬롯이 모여 하나의 버킷을 형성함
**Synonym:** 충돌로 인해 같은 Home Address를 갖는 레코드들의 집합

**해심 함수**
- 폴딩법 - 키를 여러 부분으로 나누고 각 부분의 값을 더하거나 XOR한 값을 홈 주소로 얻음
- 제산법 (Division) - h(K) = K % Q
- 제곱법 (Mid-Square) - 레코드 키 값(K)을 제곱한 후 그 중간 부분의 값을 홈 주소로 삼
- 숫자 분석법 (Digit Analysis) - 키 값을 이루는 숫자의 분포를 분석하여 비교적 고른 자리를 필요한 만큼 택해서 홈 주소로 삼
#### DB 개요
**정의:** 통합된 데이터 (Integrated), 저장된 데이터, 운영 데이터 (Operational), 공용 데이터 (Shared)
**필수 기능:** 
- 정의 - 모든 응용 프로그램들이 요구하는 데이터 구조를 지원하기 위해 데이터베이스에 저장될 데이터의 형과 구조에 대한 정의, 이용 방식, 제약 조건 등을 명시
- 조작 - 데이터 검색, 갱신, 삽입, 삭제 등을 체계적으로 처리하기 위해 사용자와 데이터베이스 사이의 인터페이스 수단을 제공
- 제어 - 데이터베이스를 접근하는 갱신, 삽입, 삭제 작업이 정확하게 수행되어 데이터의 무결성이 유지되도록 제어

**스키마**
- 개념 - 조직이나 기관의 총괄적 입장에서 본 데이터베이스의 논리적 구조; 접근 권한, 보안 정책, 무결성 규칙
- 외부 - 사용자나 응용 프로그래머가 각 개인의 입장에서 필요로 하는 DB 논리적 구조 정의
- 내부 - 실제 데이터베이스가 물리적 기억장치 내에 저장; 저장될 레코드의 형식 정의
#### DB 설계
**순서:** 요구 조건 분석 -> 개념적 설계 -> 논리적 설계 -> 물리적 설계 -> 구현

**개념적 설계**
- 현실 세계에 대한 인식을 추상적 개념 표현
- 개념 스키마 모델링 + 트랜잭션 모델링
- DBMS 독립적인 E-R Diagram 작성 + 개념 스키마 설계

**논리적 설계**
- 논리적 데이터 모델로 변환 (Mapping)
	- 논리적 데이터 모델: 현실 세계의 자료가 DB로 표현될 수 있는 물리적 구조로 기술
- 트랜잭션 인터페이스 설계
- 개념 스키마의 평가 및 [[Dictionary#ㅈ|정제]] 등

**물리적 설계**
- 물리적 구조의 데이터로 변환
- (필수) DB 파일의 저장 구조 및 액세스 경로를 결정
- (필수) 저장 레코드의 양식 설계
- (필수) 레코드 집중 (Record Clustering) 의 분석 및 설계
- (선택) 응답 시간, 저장 공간의 효율화, 트랜잭션 처리도
#### 데이터 모델의 개념
**표시할 요소** 
- 구조 - 논리적으로 표현된 개체 타입들 간의 관계로서 데이터 구조 및 정적 성질을 표현
- 연산
- 제약 조건

**구성 요소:** 개체 (Entity), 관계
#### 개체-관계 모델 (E-R Model)
1976년 P. Chen이 제안한 것

**Diagram:** 개체 타입 (사각형), 관계 타입 (다이아몬드; 마름모), 속성 (타원), 개체 타입 속성 연결 (선)
#### 관계형 데이터 모델 (Relational Data Model)
**개요**
- 2D 테이블을 이용하여 데이터 상호 관계로 정의
- 개체 집합은 공통 속성으로 만들어진다
- 해당 데이터 모델링의 대표적인 언어는 SQL
#### 관계형 데이터베이스 (Relational DB)
![[Pasted image 20250223224455.png]]
**튜플** 
- 속성의 모임
- 각각의 행
- 튜플의 수 = Cardinality

**속성**
- DB를 구성하는 가장 작은 논리적 단위
- 속성의 수 = Degree 

**릴레이션의 특징**
- 한 릴레이션에 포함된 튜플들은 모두 상이하다 (unique) + 사이에 순서 없음
- 튜플들의 삽입, 삭제 등의 작업으로 인해 릴레이션은 시간에 따라 변한다
- 릴레이션 스키마를 구성하는 속성들 간의 순서는 중요하지 않다
- 속성의 유일한 식별을 위해 속성의 명칭은 유일해야 하지만, 속성을 구성하는 값은 동일한 값 can exist

**키**
- 슈퍼키 (Super Key) - 한 릴레이션 내에 있는 속성들의 집합으로 구성된 키로서 릴레이션을 구성하는 모든 튜플들 중 슈퍼키로 구성된 속성의 집합과 동일한 값은 나타나지 않음
	- any set of attributes that uniquely identifies each tuple of a relation
- 후보키 (Candidate Key) - 릴레이션을 구성하는 속성들 중에서 튜플을 유일하게 식별하기 위해 사용하는 속성들의 부분집합 (aka 기본키로 사용할 수 있는 속성)
	- 유일성 + 최소성
	- a candidate key is a minimal superkey
- 대체키 (Alternate Key) - 후보키가 둘 이상일 때 기본키를 제외한 나머지 후보키

**무결성 (Integrity)**
- 개체 무결성 (Entity Integrity) - 릴레이션의 기본키를 구성하는 어떤 속성도 널(Null) 값이나 중복 값을 가질 수 없음 
- 참조 무결성 - 외래키 값은 Null이거나 참조 릴레이션의 기본키 값과 동일해야 함
- 도메인 무결성 - 주어진 속성 값이 정의된 도메인에 속한 값이어야 한다
- 사용자 정의 무결성 - 속성 값들이 사용자가 정의한 제약 조건에 만족해야 한다
#### 관계대수 (Relational Algebra) & 관계해석 (Predicate Calculus) 
**관계대수:** 연산의 결과로 새로운 릴레이션이 생성되는 절차적 언어를 의미하는 것

**순수 관계 연산자**
- Select (σ)
- Project (π)
- Join (⋈)
- Division (÷)

**일반 집합 연산자**: 
- 합집합/Union (∪)
- 교집합/Intersection (∩)
- 차집합/Difference (-)
- 교차곱/Cartesian Product(×)
	- 차수 (Degree) 더하기; 카디널리티 곱하기

**관계해석**
- propsed by Edgar F. Codd
- 원하는 정보가 무엇이라는 것만 정의하는 비절차적 특성
#### 정규화 (Normalisation)
**개요**
- 잘못 설계 된 관계형 스키마를 더 작은 속성의 세트로 쪼개는 과정
- 하나의 종속성 (Dependency)이 하나의 릴레이션에 표현될 수 있도록 분해

**목적**
- 데이터 중복을 배제하여 이상의 발생 방지 및 자료 저장 공간 최소화
- 새로운 형태의 데이터가 삽입될 때 릴레이션을 재구성할 필요성을 줄이는 것

**과정:** 도부이결다조
- 비정규 -> 1NF -> 2NF -> 3NF -> BCNF -> 4NF -> 5NF
	- 비정규 -> 1NF: 도메인이 원자값
	- 1NF -> 2NF: 부분적 함수 종속 (Partial FD) 제거
	- 2NF -> 3NF: 이행적 함수 종속 (Transitive FD) 제거
	- 3NF -> BCNF: 결정자이면서 후보키가 아닌 것 제거
	- BCNF -> 4NF: 조인 종속성 이용

**이상 (Anomaly):** 삽입, 삭제, 갱신
#### 비정규화 (Denormalisation)
**개념** 
- 시스템 성능 향상
- 개발 및 운영의 편의성 등을 위해 정규화된 데이터 모델을 통합, 중복, 분리
	- 외도적으로 정규화 원칙을 위배

**중복 테이블 추가 방법**
- 집계 테이블의 추가
- 진행 테이블의 추가
- 특정 부분만을 포함하는 테이블의 추가
#### 뷰 (View)
**개요:** 하나 또는 둘 이상의 기본 테이블로부터 유도되어 만들어진 가상 테이블
- 삽입, 삭제, 갱신 연산이 x

**장점**
- 논리적 데이터 독립성을 제공
- 사용자의 데이터 관리를 간단하게 해줌
- 접근 제어를 통한 자동 보안이 제공

**단점**
- 독립적인 인덱스를 가질 수 없음
- 뷰의 정의를 변경할 수 없음
- 뷰로 구성된 내용에 대한 삽입, 삭제, 갱신 연산에 제약
#### 시스템 카탈로그/트랜잭션
**시스템 가탈로그**
- 객체에 관한 정보를 포함하는 시스템 DB
- 일반 이용자도 SQL을 이용하여 내용을 검색해 볼 수 있다
- `INSERT`, `DELETE`, `UPDATE`문으로 갱신하는 것은 허용하지 않는다

**시스템 트랜잭션**
- 원자성 (Atomicity) - ALL OR NONE (Commit or Rollback)
- 일관성 (Consistency) - 트랜잭션의 그 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환함
- 독립성 (Isolation) - 둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 어느 하나의 트랜잭션 실행 중에 다른 트랜잭션의 연산이 끼어들 수 없다
- 영속성, 지속성 (Durability) - 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 함

---
### ==SQL 활용==
#### `SELECT`
**`LIKE` Operator**
- `*` or `%` - 모든 문자
- `_` - 문자 하나
- `#` - 숫자 하나
	- e.g. `WHERE 생일 BETWEEN #01/09/69$ AND #10/22/73#`
#### `JOIN`
**`INNER JOIN`**
- `EQUI JOIN` - Natural join; uses '`=`'; 중복되는 조인 속성 제거
- `NON-EQUI JOIN`

**`OUTER JOIN:`** 릴레이션에서 `JOIN` 조건에 만족하지 않는 튜플도 결과로 출력
- `LEFT OUTER JOIN`
- `RIGHT OUTER JOIN`
- `SELF JOIN`

